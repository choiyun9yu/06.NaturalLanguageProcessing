# JAVA BASIC

## 1. 클래스와 데이터

### 1-1. 클래스가 필요한 이유
- 코드의 변경이 있을 때 유지보수하기 용이하다.
- 사람이 이해하고 관리하기 편리하다.

### 1-2. 클래스 도입
- 클래스: 사용자 정의 자료형을 만드는 설계도 이다.
- 인스턴스: 설계도인 클래스에 의해 만들어져서 실제 메모리에 로드된 실체이다.
- 클래스명은 첫글자가 대문자인 카멜표기법을 사용한다.
- 변수는 소문자로 시작하는 카멜표기법을 사용한다.
####
- 객체를 사용하려면 먼저 설계도인 클래스를 기반으로 인스턴스를 생성해야한다.
- 인스턴스는 생성자를 사용해서 메모리에 실제 객체를 생성한다. (생성 시 이 객체를 사용할 때 필요한 메모리 공간도 함께 확보한다.)
- 객체를 생성하면 자바는 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조값(주소)를 반환한다.
#### 
    Student student1 = new Student();   // 1. Student 객체 생성
    Student student1 = x001;            // 2. new Student의 결과로 x001 참조값 반환
    student1 = x001;                    // 3. 최종 결과

    // 여기선 임의로 x001이라고 표현했는데 System.out.println(student1); 을 실행하면 @뒤에가 참조 값이다.

### 1-3. 객체 사용
- 객체이름 뒤에 dot(.)을 붙여서 접근한다.
- student1.name은 student1 인스턴스의 name 필드에 접근한다.

### 1-4. 클래스, 객체, 인스턴스 정리
- 객체: 객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다.
- 인스턴스: 인스턴스는 특정 클래스로부터 생성된 객체를 의미한다. 인스턴스는 주로 객체가 어떤 클래스에 속해있는지 강조할 때 사용한다.
- 객체 vs 인스턴스: 둘다 클래스에서 나온 실체라는 의미에서 비슷하게 사용되지만, 용어상 인스턴스는 객체보다 좀 더 관계에 초점을 맞춘 단어이다.

### 1-5. 배열 도입 - 시작
- 클래스 배열을 사용하면 특정 타입을 연속한 데이터 구조로 묶어서 편리하게 관리할 수 있다.
- Student 타입을 보관할 수 있는 Students 배열을 만들면 배열은 Student 타입의 참조값을 보관하는 배열로 생성된다.   
  (배열에는 아직 참조값을 대입하지 않았기 때문에 참조값이 없다는 의미의 null 값으로 초기화 된다.)
- **!자바에서 대입은 항상 변수에 들어 있는 값을 복사한다!**
- **!변수에는 인스턴스 자체가 들어 있는 것이 아니라 인스턴스의 위치를 가르키는 참조 값이 들어있을 뿐이다!**
- 따라서 인스턴스가 복사되는 것이 아니라 인스턴스에 접근할 수 있는 참조값만 복사된다. (인스턴스가 아니라 접근하는 방법이 늘어나는 것)
- 이런경우 반복문을 향상된 for문을 사용해서 최적화하면 좋다. (iter 입력하면 자동 생성)

### 1-6. 배열 도입 - 리펙토링

### 1-7. 문제와 풀이

<br>

## 2. 기본형과 참조형

### 2-1. 기본형 vs 참조형1 -시작

### 2-2. 기본형 vs 참조형2 -변수 대입

### 2-3. 기본형 vs 참조형3 -메서드 호출

### 2-4. 참조형과 메서드 호출 -활용

### 2-5. 변수와 초기화

### 2-6. null

### 2-7. NullPointerException

### 2-8. 문제와 풀이

<br>

## 3. 객체 지향 프로그래밍

### 3-1. 절차 지향 프로그래밍1 - 시작

### 3-2. 절차 지향 프로그래밍2 - 데이터 묶음

### 3-3. 절차 지향 프로그래밍3 - 메서드 추출

### 3-4. 클래스와 메서드

### 3-5. 객체 지향 프로그래밍

### 3-6. 문제와 풀이

<br>

## 4. 생성자

### 4-1. 생성자 -필요한 이유

### 4-2. this

### 4-3. 생성자 -도입

### 4-4. 기본 생성자

### 4-5. 생성자 - 오버로딩과 this()

### 4-6. 문제와 풀이

<br>

## 5. 패키지

### 5-1. 패키지 -시작

### 5-2. 패키지 -import

### 5-3. 패키지 규칙

### 5-4. 패키지 활용

<br>

## 6. 접근 제어자

### 6-1. 접근 제어자 이해1

### 6-2. 접근 제어자 이해2

### 6-3. 접근 제어자 종류

### 6-4. 접근 제어자 사용 -필드, 메서드

### 6-5. 접근 제어자 사용 -클래스 레벨

### 6-6. 캡슐화

### 6-7. 문제와 풀이

<br>

## 7. 자바 메모리 구조와 static

### 7-1. 자바 메모리 구조

### 7-2. 스택과 큐 자료 구조

### 7-3. 스택 영역

### 7-4. 스택 영역과 힙 영역

### 7-5. static 변수1

### 7-6. static 변수2

### 7-7. static 변수3

### 7-8. static 메서드1

### 7-9. static 메서드2

### 7-10. static 메서드3

### 7-11. 문제와 풀이

<br>

## 8. final

### 8-1. final 변수와 상수1

### 8-2. final 변수와 상수2

### 8-3. final 변수와 참조

<br>

## 9. 상속

### 9-1. 상속 -시작

### 9-2. 상속 관계

### 9-3. 상속과 메모리 구조

### 9-4. 상속과 기능 추가

### 9-5. 상속과 메서드 오버라이딩

### 9-6. 상속과 접근 제어

### 9-7. super -부모 참조

### 9-8. super -생성자

### 9-9. 문제와 풀이

<br>

## 10. 다형성1

### 10-1. 다형성 시작

### 10-2. 다형성과 캐스팅

### 10-3. 캐스팅의 종류

### 10-4. 다운캐스팅과 주의점

### 10-5. instanceof

### 10-6. 다형성과 메서드 오버라이딩

<br>

## 11. 다형성2

### 11-1. 다형성 활용1

### 11-2. 다형성 활용2

### 11-3. 다형성 활용3

### 11-4. 추상 클래스1

### 11-5. 추상 클래스2

### 11-6. 인터페이스

### 11-7. 인터페이스 -다중 구현

### 11-8. 클래스와 인터페이스 활용

<br>

## 12. 다형성과 설계

### 12-1. 좋은 객체 지향 프로그래밍이란?

### 12-2. 다형성 -역할과 구현 예제1

### 12-3. 다형성 -역할과 구현 예제2

### 12-4. 다형성 -역할과 구현 예제3

### 12-5. OCP(Open-Closed Principle) 원칙

### 12-6. 문제와 풀이

<br>

## 13. 다음으로