# Java Part3

## 1. 클래스

클래스는 객체지향프로그래밍에서 객체를 생성할 때 필요한 설계도와 같은 것이다. 클래스의 용도는 크게 2가지 이다. 클래스는 main() 메소드를 가지고 있어 실행 가능한 실행 클래스와 실행할 수 없고 다른 클래스에서 이용하는 라이브러리 클래스로 나뉜다.

**인스턴스**는 클래스라는 설계도로 실제로 메모리에 생성한 객체이다.(이때 객체는 heap 영역에 생성된다.) 필드와 메소드는 선언 방법에 따라 인스턴스 멤버와 정적 멤버로 분류될 수 있다. 인스턴스 멤버로 선언되면 객체 생성 할 수 있고 정적(static) 멤버로 선언되면 객체 생성 없이 사용할 수 있다. 인스턴스 멤버는 객체에 소속된 멤버이다. 따라서 객체가 있어야만 사용할 수 있다.

### 1-1. 인스턴스 멤버(Instance member)
인스턴스 멤버는 객체(인스턴스)의 상태와 동작을 나타내는 클래스 멤버이다. 따라서 인스턴스 멤버는 객체를 생성해야지만 메모리에 로딩되고 사용할 수 있게 된다. 

#### 필드(Field), 인스턴스 변수

객체의 데이터(고유값, 상태)를 저장하는 역할을 한다. 초기값 미제공시 초기화 시 타입별 기본값을 보여준다.

#### 메서드(Method), 인스턴스 메서드

객체가 수행할 동작이다. 메소드는 호출 시 메소드 영역(스택 영역(LIFO))에 적재된다. 메소드는 코드 덩어리이므로 객체마다 저장하면 중복 저장으로 메모리 효율이 떨어진다. 따라서 메소드 코드는 메소드 영역에 두고 공유해서 사용한다.(단, 객체가 없으면 사용하지 못하도록 제한을 걸어둔다.)    

main메소드가 Static영역에서 실행되면서 가장먼저 스택 영역에 적재되고 필요한 메소드들을 호출하면서 스택을 쌓아가다가 모든 메소드가 종료되면 마지막에 main 메서드도 종료되면서 메모리 릴리즈 한다.

#### 생성자(Constructor)
생성자는 new연산자로 객체를 생성할때 호출되는 특수 메서드이며, 클래스와 이름이 같다. 생성자에서는 반드시 알아야할 두가지 개념이 있다.
-   오버로딩(Overloading): 매개변수를 달리하는 생성자를 여러 개 선언하는 것이다. 생성자 오버로딩이 많아지는 경우 생성자 간의 중복코드가 발생할 수 있다. 이런 경우 공통 코드는 한 생성자에게만 집중적으로 작성하고, 나머지 생성자는 this.(매개값..)를 사용하여 공통 코드를 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다.
-   오버라이팅(Overwriting): 상속받은 클래스에서 생성자 재정의 하는 것이다.

#### this 키워드

인스턴스 블록 내부(객체 내부)에서 인스턴스 멤버에 접근하기 위해서 this를 사용한다. this를 사용하지 않으면 매개변수로 받은 변수와 구분이 어려울 수 있기 때문에 this로 명확히 표시해주는 것이 좋다.

    public class MinMax{
        // 필드 선언
        int max;
        int min;
        // 메소드 선언
        public int sum(int max, int min){
            this.max = max;  	        // this가 붙은건 클래스의 필드
            this.min = min;		        // this가 안붙은건 매개변수로 받은 변수
            return this.max - this.min;	// 이름이 같을 때 구분하기위해 사용
        }
    }

### 1-2. 정적 멤버(Static member)
정적 멤버는 메소드 영역의 클래스에 고정적으로 위치하는 멤버이다. 그렇기 때문에 정적 멤버는 객체를 생성할 필요 없이 클래스가 메모리에 로딩되면 바로 사용할 수 있다. 정적 메소드와 정적 블록은 객체가 없어도 실행된다는 특징 때문에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 객체 자신의 참조인 this도 사용할 수 없다. (객체를 생성해야 사용할 수 있는 것들을 사용할 수 없다.)

### 1-3. final 필드와 상수

인스턴스 필드와 정적 필드는 언제든지 값을 변경할 수 있다. 그러나 경우에 따라서는 값을 변경하는 것을 막고 읽기만 허용해야 할 때가 있다. 이때 final 필드와 상수를 선언해서 사용한다.

#### final 선언

final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없게 된다.

    // 필드 선언 시 초기값 대입
    final 타입 필드명 = 초기값;

    // 생성자로 초기값 대입
    public class Korean {
        final nation;
        public Korean(String nation) {
            this.nation = nation;	// 매개변수로 들어오는게 초기값
        }
    }

#### 상수(constant) 선언

원주율과 같은 불변값을 저장하는 필드를 상수 필드라고 한다. 상수는 객체마다 저장할 필요가 없고, 여러 개의 값을 가져도 안되기 때문에 Static이면서 final인 특성을 가져야 한다.

초기 값은 선언 시에 주는 것이 일반적이지만, 복잡한 초기화가 필요한 경우에는 정적 블록에서 초기화 할 수 있다. (상수명은 모두 대문자로 하는 것이 관례이다.)

    // 선언시 초기값 대입
    static final 타입 상수명 = 초기값;

    // static block에서 대입
    static final 상수명;
    static {
        상수명 = 초기값;
    }

### 1-4. 패키지

패키지는 클래스를 식별하는 용도로 사용된다. 

#### 패키지 선언

    // 패키지 선언
    pacakge 상위패키지.하위패키지;

    public class 클래스명 {
        ...
    }

패키지 이름은 모두 소문자로 작성하는 것이 관례이다. 패키지 이름이 서로 중복되지 않도록 회사 도메인 이름의 역순으로 작성하고 마지막에는 프로젝트 이름을 붙여주는 것이 일반적이다.

    (ex) com.samsung.projectname
    (ex) com.lg.proejectname

#### import 문

같은 패키지에 있는 클래스는 아무런 조건 없이 사용할 수 있지만, 다른 패키지에 있는 클래스를 사용하기 위해서는 import문을 통해 어떤 패키지의 클래스를 사용할 것인지 명시해야 한다. 또한 import 문은 하위 패키지를 포함하지 않기 때문에 하위 패키지도 다 import 해야한다.  

만약 서로 다른 패키지에 동일한 클래스이름이 존재한다면 풀네임으로 어떤 패키지의 클래스인지 명시해줘야 컴파일 에러가 발생하지 않는다.

    import com.hankook.*;	            // *는 모두 가져오겠다는 의미
    import com.hankook.projectname.*;

#### 접근 제한자(Access Modifier)
| 접근 제한자    | 내용                                         |
|-----------|--------------------------------------------|
| public    | 모든 패키지에서 아무 제약없이 접근 가능하다.                  |
| private   | 모든 패키지에서 접근 불가, 객체 내부에서만 접근 가능하다.          |
| protected | 같은 패키지 또는 상속 관계에서 하위 클래스에서 상위 클래스 접근 가능하다. |
| (default) | 동일한 패키지에서만 접근 가능하다. (접근제한자가 붙지 않은 상태 의미)   |

#### Getter와 Setter

객체의 필드(데이터)를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성을 저해할 수 있다. 따라서 외부에서 필드 접근을 막고 대신 메소드를 통해 필드에 접근하는 것이 선호된다. 이때 사용하는 것이 Getter()와 Setter() 메소드이다.

-   Setter() : 해당 필드값 변환
-   Getter() : 해당 필드값 반환
-   toString() : getter로 일일이 하나씩 가져오기 불편할 때 필드 값 한번에 반환
-   생성자 이용 객체 초기화 : 생성자로 필드에 값을 삽입

#### 싱글톤 패턴
애플리케이션 전체에서 단 한개의 객체만 생성해서 사용하고 싶을 때 사용한다. 생성자를 private 접근 제한해서 외부에서 new연산자로 생성자를 호출할 수 없도록 막는 것이 핵심이다. 생성자를 호출할 수 없으니 외부에서 마음대로 객체를 생성하는 것이 불가능하다. 대신 싱글톤 패턴이 제공하는 정적 메소드를 통해 간접적으로 객체를 얻는다.

    public class 클래스 {

        // private 접근 권한을 갖는 정적 필드 선언과 초기화
        private static 클래스 singleton = new 클래스(); // 자신의 타입으로 정적 필드 선언
    
        // pricate 접근 권한을 갖는 생성자 선언
        pricate 클래스() {}
        
        // public 접근 권한을 갖는 정적 메소드 선언
        public static 클래스 getInstance() {		// 정적 필드값을 리턴하는 메소드
          return singleton;
        }
    }

<br>
<br>

## 2. 상속(Inheritance)

상속은 중복 코드를 줄여준다. 이미 잘 개발된 클래스를 재사용할 수 있기 때문이다. 상속의 또 다른 장점은 클래스의 수정을 최소화할 수 있다는 것이다. 부모 클래스를 수정하면 상속 받은 자식클래스들은 중복되는 코드는 따로 수정하지 않아도 된다.

현실에서는 부모가 자식을 선택하지만, 프로그램에서는 자식이 부모를 선택하여 상속 받는다. 또한, 다른 언어와 달리 자바는 다중 상속을 허용하지 않는다.(자식당 부모클래스 1개만 가능)

    public class 자식클래스 extends 부모클래스{

    }

### 2-1. 상속관계

#### 부모 생성자 호출

현실에서 부모없는 자식이 있을 수 없듯이 자바에서도 자식 객체를 생성하면 부모 객체가 먼저 생성된 다음 자식 객체가 생성된다.  

컴파일 과정에서 super()메소드가 자식 생성자 맨 첫줄에 삽입된다. 그러나 super()는 부모 클래스의 기본 생성자만 호출할 수 있다. 만약 부모 클래스의 기본 생성자가 없고, 매개변수를 갖는 생성자만 있다면 super(매개값, ...); 코드를 자식 생성자의 첫줄에 직접 넣어야한다.

#### 메소드 재정의(오버라이팅)

물려 받은 부모 클래스의 메소드를 자식 클래스에 맞게 덮어 쓰는 작업이다. 오버라이팅되면 부모 메소드는 숨겨지고, 자식 메소드가 우선 사용된다.

!주의사항

-   부모 메소드의 선언부(리턴타입, 메소드이름, 매개변수)와 동일해야한다.
-   접근 제한을 더 강하게 오버라이딩 할 수 없다(public -> private 불가)
-   새로운 예외를 throws할 수 없다.

자바는 개발자의 실수를 줄이기 위해 정확히 오버라이딩 되었는지 확인하는 @Override 어노테이션을 제공한다. @Overried를 붙이면 컴파일 단계에서 정확히 오버라이딩 되었는지 체크하고, 문제가 있다면 컴파일 에러를 출력해준다.

#### 부모 메소드 호출

오버라이딩 하면 부모가 100줄 코드를 가지고 있고 자식은 거기에 1줄만 추가하고 싶어도 자식클래스에서 부모 코드의 100줄을 다시 작성해야 한다. 이 문제는 자식 메소드와 부모 메소드의 공동 작업 처리 기법으로 해결할 수 있다. 자식 메소드 내에서 부모 메소드를 호출하는 것이다.

    class Parent {
        public void 메소드() {
            작업코드1
        }
    }

    class Child extends Parent {
        public void 메소드() {
            super.메소드();
            작업코드2
        }
    }

#### final 클래스와 final 메소드

    final 타입 필드명 = 초기값; // final 필드는 초기값 설정 후 값을 변경할 수 없다.

    public final 리턴타입 메소드명(매개변수...) {
        // final 메소드는 더 이상 오버라이딩 할 수 없다.
    }

    public final class 클래스명 {
        // final 클래스는 더 이상 상속할 수 없다.
    }

### 2-2. 다형성

#### 클래스의 타입 변환

클래스의 타입 변환은 상속 관계에 있는 클래스 사이에서 발생한다.

- **자동 타입 변환(promotion)**
    자식타입의 객체를 부모타입의 변수에 대입할 때 자동으로 타입 변환 되는 것이다. 또한 바로 위의 부모가 아니더라도 상속 계층에서 상위 타입이라면 자동 타입변환 가능하다.   
    예를 들어 동물(부모) 변수에 고양이(자식)객체를 넣어도 대입이 된다는 것이다. 이때 자식 객체와 부모 변수는 타입만 다를 뿐 힙 영역에 동일한 인스턴스를 가리키게 된다.   
    단, 부모 타입으로 자동 타입 변환 된 이후에는 부모 클래스에 선언된 필드와 메소드에만 접근 가능하다. 변수는 자식 인스턴스를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정된다.   
    그러나 자식 클래스에서 오버라이딩된 메소드가 있다면 부모 메소드 대신 오버라이딩된 메소드가 호출된다. 이것은 다형성과 관련이 있기 때문에 꼭 알아두어야 한다.

        Cat cat = new Cat();
        Animal animal = cat;	// Cat 타입이 자동으로 Animal 타입으로 변환된다.
  
- **강제 타입 변환(Casting)**  
   자식타입은 부모타입으로 자동 타입 변환되지만, 부모타입은 자식타입으로 자동 타입 변환 되지 않는다. 따라서 캐스팅 연산자로 강제 타입 변환 시켜줘야한다.   
   그렇다고해서 부모 타입 객체를 자식 타입으로 무조건 강제 변환할 수 있는 것도 아니다. 자식 객체가 부모 타입으로 먼저 자동 변환된 후 다시 자식타입으로 변환할 때 강제 타입 변환을 사용할 수 있는 것이다.   
   부모타입으로 변환된 자식객체가 다시 자식 타입으로 선언된 필드와 메소드를 쓰고 싶을 때, 강제 타입 변환을 해서 자식객체에 선언된 필드와 메소드를 사용한다.

        자식타입 변수명 = (자식타입) 부모타입객체;
    
        Parent parent = new Child();	// 자동 타입 변환
        Child child = (Child) parent;	// 강제 타입 변환

#### 다형성

다형성이란 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질이다. 프로그램의 객체는 부품과 같아서, 프로그램을 구성하는 객체를 바꾸면 프로그램의 실행 성능이 다르게 나올수 있다. 이때 객체 사용 방법이 동일하다는 것은 동일한 메소드를 가지고 있다는 뜻이다. 다형성을 구현하기 위해서는 자동 타입변환과 메소드 재정의가 필요하다.

- **필드 다형성**: 필드 타입은 동일하지만, 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것을 말한다.


- **매개변수 다형성**: 참조형 매개변수는 메소드 호출시 자신과 동일한 타입 or 자식 타입의 인스턴스를 넘겨줄 수 있다. 자식 타입의 인스턴스를 넘겨줄 수 있는 이유는 '자동 타입 변환' 덕분이다. 자식 타입의 인스턴스가 왔고 자식 클래스가 부모 클래스의 메소드를 오버라이딩하고 있다면 메소드 호출시 오버라이딩 된 자식 클래스의 메소드가 실행된다. 따라서 매개변수로 무엇이 들어오느냐에 따라 실행 결과가 다양하게 나올 수 있는 것이다.

#### 객체 타입 확인 : 객체 instanceof 타입

어떤 객체가 매개변수로 들어오는지에 따라 결과가 다양하게 바뀐다면, 그 객체를 확인할 필요가 있다.  
(반드시 매개변수가 아니더라도 변수가 참조하는 객체의 타입을 확인할 때 instanceof 연산자를 사용한다.)

    boolean result = 객체 instanceof 타입

    // Java 11 까지
    public void method(Parent parent) {
        if(parent instanceof Child) {
            Child A = (Child) parent;	// 강제 타입 변환
            // A 변수 사용 가능
        }
    }

    // Java 12 부터 우측타입 변수 사용할 수 있어 강제 타입 변환이 필요없다.
        if(parent instaceof Child A) {
            // A 변수 사용 가능
        }

### 2-3.추상 클래스

사전적 의미로 추상은 실체 간에 공통되는 특성을 추출한 것이다.

#### 추상 클래스

객체를 생성할 수 있는 클래스를 실체 클래스라고 한다면, 이 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스를 추상 클래스라고 한다.

추상 클래스는 실체 클래스들의 부모 역할을 한다. 따라서 실체 클래스는 추상 클래스를 상속해서 공통적인 필드나 메소드를 물려받을 수 있다.

단, 추상 클래스는 새로운 실체 클래스를 만들기 위한 부모 클래스로만 사용되기 때문에 new연산자를 사용하여 객체를 직접 생성할 수 없다.

    public abstract class 추상클래스명 {
        // 필드
        // 생성자
        // 메소드
    }

#### 추상 메서드

자식 클래스들이 가지고 있는 공통 메소드를 뽑아내어 추상 클래스로 작성할 때, 메소드 선언부(리턴타입, 메소드명, 매개변수)만 동일하고 실행 내용은 자식 클래스마다 달라야하는 경우가 많다.

이런 경우 추상 클래스는 추상 메소드를 선언할 수 있다. 일반 메소드와 차이점은 abstract 키워드가 붙고, 메소드 실행 내용인 중괄호({ })가 없다는 것이다.

실행내용이 없기 때문에 자식 클래스에서 반드시 오버라이딩 해야한다.

    abstract 리턴타입 메소드명(매개변수, ...);

#### 봉인된 클래스(sealed class)

기본적으로 final 클래스를 제외한 모든 클래스는 부모 클래스가 될 수 있다. 그러나 Java 15 부터는 무분별한 자식 클래스 생성을 방지하기 위해 봉인된(sealed) 클래스가 도입되었다.

예를 들어 Person의 자식 클래스는 Employee와 Manager만 가능하고, 그 이외에는 자식 클래스가 될 수 없도록 할 수 있다.

    public sealed class Person permits Employee, Manager{...}

봉인된 클래스를 상속받는 클래스는 final, 또다른 sealed, non-sealed 키워드를 사용해 선언해야 한다.

    public sealed class Employee extends Person {...}
    public non-sealed class Manager extends Person {...}

    // non-sealed는 봉인을 해제하는 키워드
    public class Director extends Manager{...}

<br>
<br>

## 3. 인터페이스(Interface)
클래스가 구현해야 하는 메서드 세트를 정의하는 추상 형식이다. 인터페이스는 추상 메서드(abstract method)와 상수(constant)로 구성된다. Java에서 인터페이스는 interface 키워드를 사용하여 정의되며, 클래스가 implements 키워드를 사용하여 인터페이스를 구현할 수 있다.

### 3-1. 인터페이스 생성

인터페이스 생성

-   Eclipse : New - Interface
-   Intelli J : New - Java Class - Interface

#### 인터페이스 선언

인터페이스 선언은 class 키워드 대신 interface 키워드를 사용한다.
중괄호 안에는 인터페이스가 가지는 멤버들을 선언할 수 있다.

    public interface 인터페이스명 {...}
        // public 상수 필드
        // public 추상 메소드
        // public 디폴트 메소드
        // public 정적 메소드
        // private 메소드
        // private 정적 메소드

#### 구현 클래스 선언
구현 클래스는 implements 키워드로 인터페이스를 구현한다. (extends 키워드로 상속받는 것과 비슷하지만 다르다.)  

implements 키워드는 해당 클래스가 인터페이스를 사용할 수 있다는 표시이며, 인터페이스의 추상 메소드를 재정의한 메소드가 있다는 뜻이다.

    public class 클래스명 implements 인터페이스명 {
        ...
        }

#### 변수 선언과 구현 객체 대입

인터페이스도 하나의 object이므로 변수 타입으로 사용할 수 있다. 인터페이스는 참조 타입에 속하므로 인터페이스 변수에는 객체를 참조하고 있지 않다는 뜻으로 null을 대입할 수 있다.

만약 클래스가 implements 인터페이스명으로 선언되어 있지 않다면, 인터페이스 타입의 변수에 대입할 수 없다.

인터페이스 변수를 통해 메소드가 호출되면, 실제로 실행되는 것은 인터페이스를 구현한 객체의 메소드이다.

    // 인터페이스 선언
    public interface RemoteController {
        //public 추상 메소드
        public void turnOn();
    }

    // 구현클래스 선언
    public class TV implements RemoteController {
        @Override
        public void turnOn() {
            System.out.println("TV를 켭니다.");
        }
    }

    // 메인에서 인터페이스 변수에 메소드 호출을 넣으면 구현 클래스 메소드를 반환
    public class InterFaceExample {
        public static void main(String[] args) {
            RemoteControl remocon ; // 인터페이스 객체 선언
            remocon = new TV();     // 인터페이스 객체에 대입
            remocon.turnOn();       // 인터페이스 객체에 메소드 호출
        }
    }

    // 출력결과 : TV를 켭니다.

#### 인터페이스와 상수 필드

인터페이스는 public static final 특성을 갖는 불변의 상수 필드를 멤버로 가질 수 있다.
인터페이스에 선언된 필드는 모두 public static final 특성을 갖기 때문에 public static final을 생략하더라도 자동적으로 컴파일 과정에서 붙는다.

상수는 구현 객체와 관련 없는 인터페이스 소속 멤버이므로 인터페이스로 바로 접근해서 상수 값을 읽을 수 있다.

    System.out.println(인터페이스명.상수필드명);

#### 인터페이스와 추상 메소드

인터페이스는 구현 클래스가 재정의해야하는 public 추상 메ㅗ드를 맴버로 가질 수 있다.
구현 클래스에서 인터페이스의 추상 메소드를 재정의할 때 주의점은 인터페이스의 추상 메소드는 기본적으로 public 접근 제한자를 갖기 때문에 public 보다 더 강한 접근 제한으로 재정의 할 수 없다.

#### 인터페이스와 디폴트 메소드

인터페이스에 완전한 실행 코드를 가진 디폴트 메소드를 선언할 수 있다. (추상 메소드는 실행부{}가 없지만 디폴트 메소드는 있다.)
선언 방법은 클래스 메소드와 동일하지만 차이점은 defualt 키워드가 리턴타입 앞에 붇는다는 것이다.

    [public] default 리턴타입 메소드명(매개변수, ...) {...}

디폴트 메소드가 실행코드를 포함하고 있을지라도 이 메소드를 호출하기 위해서는 인터페이스 변수에 구현된 인스턴스 객체가 할당되어야 한다.

또한 디폴테 메소드는 구현 객체에서 오버라이딩 할 수 있다. 이때 주의할 점은 접근 제한자 public을 반드시 붙여햐하고 default 키워드를 지워야한다.

#### 인터페이스와 정적 메소드

인터페이스에 정적 메소드도 선언할 수 있다. 추상 메소드와 디폴트 메소드는 구현 객체가 필요하지만, 정적 메소드는 구현 객체가 없어도 인터페이스만으로 호출할 수 있다.

    // 인터페이스 정적 메소드 선언
    [public | private] static 리턴타입 메소드명(매개변수, ...) {...}

    // 인터페이스 정적 메소드 호출
    인터페이스명.메소드명();

#### 인터페이스와 private 메소드

인터페이스의 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드는 모두 public 접근 제한을 갖는다. 이 멤버들을 선언할 때에는 public을 생략하더라도 컴파일 과정에서 public 접근 제한자가 붙어 항상 외부에서 접근이 가능하다.

그러나 private 접근 제어자를 선언할 수 도 있다. private 메소드의 용도는 디폴트와 정적 메소드들의 중복 코드를 줄이는 것이다. 디폴트 메소드의 중복 코드 부분을 private 메소드로, 정적 메소드의 중복 코드 부분을 private 정적 메소드로 선언하여 코드의 중복을 줄일 수 있다.

#### 다중 인터페이스 구현

구현 객체는 여러 개의 인터페이스를 implements할 수 있다. 구현 객체가 인터페이스 A와 인터페이스 B를 구현하고 있다면, 각각의 인터페이스를 통해 구현 객체를 사용할 수 있다.

구현 클래스는 다음과 같이 인터페이스 A와 인터페이스 B를 implements 뒤에 쉼표로 구분해서 작성해, 모든 인터페이스가 가진 추상 메소드를 재정의 해야한다.

    public class 구현클래스명 implements 인터페이스A, 인터페이스B {
        // 모든 추상 메소드 재정의
    }

구현 객체가 어떤 인터페이스 변수에 대입되느냐에 따라 변수를 통해 호출할 수 있는 추상 메소드가 결정된다.

    인터페이스A 변수명 = new 구현클래스명(...);
    인터페이스B 변수명 = new 구현클래스명(...);

### 3-2. 인터페이스 상속

인터페이스도 다른 인터페이스를 상속할 수 있으며, 클래스와는 달리 다중 상속을 허용한다.

    public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 {
        ...
        }

주의! 자식 인터페이스의 구현 클래스는 자식 인터페이스의 메소드뿐만 아니라 부모 인터페이스의 모든 추상 메소드를 재정의해야 한다. 그리고 구현 객체는 자식 및 부모 인터페이스 변수에 대입될 수 있다.

    자식인터페이스 변수명 = new 구현클래스(...);
    부모인터페이스1 변수명 = new 구현클래스(...);
    부모인터페이스2 변수명 = new 구현클래스(...);

구현 객체가 자식인터페이스 변수에 대입되면 자식 및 부모 인터페이스의 추상 메소드를 모두 호출할 수 있다. 그러나 부모인터페이스 변수에 대입되면 해당 부모 인터페이스에 선언된 추상 메소드만 호출 가능하다.

### 3-3. 인터페이스 타입 변환

인터페이스의 타입 변환은 인터페이스와 구현 클래스 간에 발생한다. 인터페이스 변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입 변환 된다. 반대로 인터페이스 타입을 구현 클래스 타입으로 변환시킬 수 있는데, 이때는 강제 타입 변환이 필요하다.

#### 자동 타입 변환

부모 클래스가 인터페이스를 구현하고 있다면, 자식 클래스도 인터페이스 타입으로 자동 타입 변환될 수 있다.

#### 강제 타입 변환

강제타입 변환은 캐스팅 기호를 사용해서 인터페이스 타입을 구현 클래스 타입으로 변환시키는 것이다.

    구현클래스 변수명 = (구현클래스) 인터페이스변수;

구현 객체가 인터페이스 타입으로 자동 변환되면, 인터페이스에 선언된 메소드만 사용 가능하다. 만약 구현 객체에서 정의한 메소드를 다시 사용하고 싶다면 강제 타입 변환으로 구현 객체로 돌아가야한다.

### 3-4. 인터페이스 다형성

현업에서는 상속보다 인터페이스를 통해 다형성을 구현하는 경우가 더 많다. 상속의 다형성과 마찬가지로 인터페이스 역시 다형성을 구현하기 위해 재정의와 자동 타이 변환 기능을 이용한다. 인터페이스의 추상 메소드는 구현 클래스에서 재정의 해야하며, 재정의되는 내용은 구현 클래스마다 다르다. 구현 객체는 인터페이스 타입으로 자동 타입 변환되고, 인터페이스 메소드 호출 시 구현 객체의 재정의된 메소드가 호출되어 다양한 실행 결과를 얻을 수 있다.

#### 인터페이스 객체 타입 확인 : instanceOf

상속에서 객체타입을 확인하는 것과 같은 방식으로 instanceOf 연산자를 사용한다.

#### 봉인된 인터페이스

봉인된 클래스와 마찬가지로 sealed와 permits을 사용하여 봉인한다.

<br>
<br>

## 4. 중첩 선언과 익명 개체

### 4-1. 중첩 클래스(Nested Class)

중첩 클래스란 클래스 내부에 선언한 클래스를 말한다. 클래스가 여러 클래스와 관계를 맺는 경우 독립적으로 선언하는 것이  
좋으나, 특정 클래스만 관계를 맺을 경우 중첩 클래스로 선언하는 것이 유지 보수에 도움이 되는 경우가 많다.

중첩 클래스를 사용하면 클래스의 맴버를 쉽게 사용할 수 있고 외부에는 중첩 관계를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.

#### 중첩 클래스의 종류

-   멤버 클래스: 클래스의 멤버로서 선언되는 중첩 클래스
-   로컬 클래스: 메소드 내부에 선언되는 중첩 클래스

중첩 클래스도 하나의 클래스이기 때문에 컴파일하면 바이트코드 파일(.class)이 별도로 생성된다.  
바이트 코드의 이름은 다음과 같이 결정된다.

    바깥클래스명 $ 멤버클래스명.class
    바깥클래스명 $1 로컬클레스명.class

#### 인스턴스 멤버 클래스

인스턴스 멤버 클래스는 다음과 같이 A클래스의 멤버로 선언된 B 클래스를 말한다. 인스턴스 멤버 클래스 B는 주로 클래스 A 내부에서 사용되므로 private 접근 제한을 갖는 것이 일반적이다. 객체 B는 클래스 A 내부 어디에서나 생성할 수는 없고, 인스턴스 필드값, 생성자, 인스턴스 메소드에서 생성할 수 있다. 객체 A가 있어야 객체 B도 생성할 수 있기 때문이다.

    [public] class A {
        [private] class B {
        }
    }

#### 정적 멤버 클래스

정적 멤버 클래스는 static 키워드와 함께 A 클래스의 멤버로 선언된 B 클래스를 말한다. 정적 멤버 클래스B는 A 클래스 내부에서 사용되기도 하지만, A 클래스 외부에서 A와 함께 사용되는 경우가 더 많기 때문에 주로 default 또는 public 접근 제한을 가진다. B 객체는 A 클래스 내부 어디든 객체를 생성할 수 있다. (static이니까)

    [public] class A {
        [public] static class B {
        }
    }

#### 로컬 클래스

생성자 또는 메소드 내부에서 선언된 클래스이다. 로컬 클래스는 몇가지 특징이 있다.

-   생성자와 메소드가 실행도리 동안에만 객체를 생성할 수 있다.
-   로컬 클래스 내부에는 필드, 생성자, 메소드 선언이 올 수 있다.
    (정적 필드와 정적 메소드는 Java 17부터 가능하다.)
-   로컬 변수를 로컬 클래스에서 사용할 경우 로컬 변수는 final의 특성을 갖게 된다.
    (Java 8 이후부터는 명시적으로 final 키워드를 붙이지 않아도 되지만 붙여주는게 좋다.)

#### 바깥 멤버 접근

중첩 클래스는 바깥 클래스와 긴밀한 관계를 맺으면서 바깥 클래스의 멤버(필드, 메소드)에 접근할 수 있다. 하지만 중첩 클래스가 어떻게 선언되었느냐에 따라 접근 제한이 있을 수 있다.

-   인스턴스 멤버 클래스 : 바깥 클래스의 모든 필드, 메소드에 접근 가능
-   정적 멤버 클래스 : 바깥 클래스의 정적 필드, 정적 메소드에 접근 가능
    (정적 멤버 클래스는 바깥 객체가 없어도 사용 가능해야 하므로 바깥 클래스의 인스턴스 필드와 인스턴스 메소드는 사용하지 못한다.)
###### 
    // 바깥 멤버 접근
    바깥클래스이름.this.변수명|메소드명

    // 자기 멤버 접근
    this.변수명|메소드명

#### 중첩 인터페이스

중첩 인터페이스는 클래스의 멤버로 선언된 인터페이스를 말한다. 인터페이스를 클래스 내부에 선언하는 이유는 해당 클래스와 긴밀하게 관계를 맺는 구현 객체를 만들기 위해서다.(객체 A없이 인터페이스를 사용하기 위해서 static 키워드를 추가할 수 있다.)

    class A {
        [public | private] [static] interface B {
        // 상수 필드
        // 추상 메소드
        // 디폴트 메소드
        // 정적메소드
        }
    }

### 4-2. 익명 객체(anonymous)

익명 객체는 이름이 없는 객체를 말한다. 명시적으로 클래스를 선언하지 않기 때문에 쉽게 객체를 생성할 수 있다. 주로 필드값, 로컬변수값, 매개변수값으로 사용된다.

익명 객체는 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. 클래스를 상속해서 만들 경우 익명 자식 객체라고 한다. 인터페이스를 구현해서 만들 경우 익명 구현 객체라고 한다.

#### 익명 자식 객체

익명 자식 객체는 부모 클래스를 상속받아 다음과 같이 생성된다. 이렇게 생성된 객체는 부모 타입의 필드, 로컬변수, 매개변수의 값으로 대입할 수 있다.
{ }중괄호 안의 필드와 메서드는 중괄호 안에서만 쓰고 버린다. 주로 부모 메소드를 재정의하는 코드가 온다.

    new 부모생성자(매개값, ...) {
        // 필드
        // 메소드
    }

#### 익명 구현 객체

익명 구현 객체는 인터페이스를 구현해서 다음과 같이 생성된다. 이렇게 생성된 객체는 인터페이스 타입의 필드, 로컬변수, 매개변수의 값으로 대입할 수 있다.

    new 인터페이스() {
        //필드
        //메소드
    }
